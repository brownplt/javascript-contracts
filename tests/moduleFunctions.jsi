{

  function isNumber(x) {
    return typeof(x) == "number";
  }
  
  function isString(x) {
    return typeof(x) == "string";
  }

  function isBool(x) { // perhaps overly strict, but great for testing
    return x === true || x === false;
  }

  function any(x) { return true; }

  function isArray(x) { return x instanceof Array; }

  var customArrayOf = function(eltContract) {
    return {
      server: function(s) {
        return function(val) {
          if (val instanceof Array) {
            return contracts.map(eltContract.server(s),val);
          }
          else {
            contracts.blame("customArrayOf violated by " + s);
          }
        };
      },
      client: function(s) {
        return function(val) {
          if (val instanceof Array) {
            return contracts.map(eltContract.client(s),val);
          }
          else {
            return val;
          }
        };
      }
    };
  };
}

// Prefix a colon to build a flat contract, where the expression on the right
// of the colon is a JavaScript predicate
num = :isNumber;

coords = { x : num, 
           y : num,
           moveRight : -> coords
         };

thunk :: -> num;
add1 :: num -> num;
sub1Broken :: num -> num; 
add :: num num -> num; 
div :: num :function(x) { return x != 0; } -> num;
makeCoords :: num num -> coords;

filter :: (:any -> :isBool) :isArray -> :isArray;
curry :: (:isNumber num -> num) num -> num -> num;
mkPair :: num num -> [ num, num ];
iota :: num -> customArrayOf(num);
sum :: num ... -> num;
reduceNumbers :: num (num num -> num) [ num, ... ] -> num;
